# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-12-13T22:00:27+00:00
# using the command:
#   datamodel-codegen --input tests\usethis\_integrations\ci\bitbucket\schema.json --input-file-type jsonschema --output src\usethis\_integrations\ci\bitbucket\schema.py --enum-field-as-literal all --field-constraints --use-double-quotes --use-union-operator --use-standard-collections --use-default-kwarg --extra-fields=allow --output-model-type pydantic_v2.BaseModel --target-python-version 3.10
# ruff: noqa: ERA001
# pyright: reportAssignmentType=false
# plus manually add Definitions.script_items for type hinting
# plus manually add ScriptItemAnchor as a root type of Script, and import it
# plus manually forbid StepItem.step from being None
# plus manually forbid Step1.step from being None
# plus manually forbid ParallelItem.parallel from being None
# plus manually forbid StageItem.stage from being None
# plus manually forbid StepBase.script from being None
# plus manually add "shared" to the Literal annotation in `StepBase.type` to match default
# plus manually set default to None for for roundtripping

from __future__ import annotations

from typing import Any, Literal

from pydantic import BaseModel, ConfigDict, Field, RootModel

from usethis._integrations.ci.bitbucket.anchor import ScriptItemAnchor


class Depth(RootModel[int]):
    root: int = Field(
        ...,
        description='The depth argument of Git clone operation. It can be either number or "full" value',
        examples=["full"],
        ge=1,
        title="Git Clone Depth",
    )


class Clone(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    depth: Depth | Literal["full"] | None = Field(
        default=None,
        description='The depth argument of Git clone operation. It can be either number or "full" value',
        examples=["full"],
        title="Git Clone Depth",
    )
    enabled: bool | None = Field(
        default=True, description="Enables cloning of the repository."
    )
    lfs: bool | None = Field(
        default=None,
        description="Enables the download of files from LFS storage when cloning.",
    )
    skip_ssl_verify: bool | None = Field(
        default=None,
        alias="skip-ssl-verify",
        description="Disables SSL verification during Git clone operation, allowing the use of self-signed certificates.",
    )


class MaxTime(RootModel[int]):
    root: int = Field(
        ...,
        description="The maximum time a step can execute for in minutes.",
        examples=[60],
        gt=0,
    )


class Size(RootModel[Literal["1x", "2x", "4x", "8x", "16x", "32x"]]):
    root: Literal["1x", "2x", "4x", "8x", "16x", "32x"] = Field(
        ...,
        description="The size of the step, sets the amount of resources allocated.",
        title="Step Size",
    )


class Key(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    files: list[str] = Field(
        ...,
        description="Checksum of these file paths will be used to generate the cache key.",
        min_length=1,
    )


class CachePath(RootModel[str]):
    root: str = Field(
        ...,
        description="Path to the directory to be cached, can be absolute or relative to the clone directory.",
        title="Cache Path",
    )


class Cloud(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    arch: Literal["x86", "arm"] | None = Field(
        default="x86", description="Architecture type used to run the step."
    )
    atlassian_ip_ranges: bool | None = Field(
        default=None,
        alias="atlassian-ip-ranges",
        description="Whether it uses Atlassian ip ranges.",
    )
    instance_type: str | None = Field(
        default=None,
        alias="instance-type",
        description="Instance type for the cloud runtime.",
    )
    version: str | None = Field(default=None, description="Cloud Runtime version.")


class Aws(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    access_key: str = Field(
        ...,
        alias="access-key",
        description="The access key for Amazon Elastic Container Registry (AWS ECR).",
        title="AWS Access Key",
    )
    secret_key: str = Field(
        ...,
        alias="secret-key",
        description="The secret key for Amazon Elastic Container Registry (AWS ECR).",
        title="AWS Secret Key",
    )


class Aws1(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    oidc_role: str = Field(
        ...,
        alias="oidc-role",
        description="OIDC role with access to private Docker images hosted in Amazon Elastic Container Registry (AWS ECR).",
        title="OpenID Connect Role",
    )


class ImageName(RootModel[str]):
    root: str = Field(
        ...,
        description="The name of the Docker image which may or may not include registry URL, tag, and digest value.",
        title="Docker Image Name",
    )


class ImportPipeline(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    import_: str = Field(
        ...,
        alias="import",
        description="The import needs to match the following format: {repo-slug|repo-uuid}:{tag-name|branch-name}:{pipeline-name}.",
        pattern="^[^:]+:[^:]+:[^:]+$",
        title="Identifier of the pipeline configuration to import",
    )


class RunsOnItem(RootModel[str]):
    root: str = Field(
        ..., description="Label of a runner.", max_length=50, title="Step Runner Label"
    )


class TriggerConfiguration(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    condition: str = Field(
        ...,
        description="Boolean expression that determines whether the trigger should execute.",
        examples=['BITBUCKET_BRANCH == "main"'],
        title="Trigger Condition",
    )
    pipelines: list[str] = Field(
        ...,
        description="List of pipeline names to trigger when the condition is met. Can reference pipelines from the custom section.",
        min_length=1,
        title="Pipeline Names",
    )


class ImageBase(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    name: ImageName
    run_as_user: int | None = Field(
        default=None,
        alias="run-as-user",
        description="The UID of a user in the docker image to run as. Overrides image's default user, specified user UID must be an existing user in the image with a valid home directory.",
        title="User ID",
    )


class StorageAwsAuth1(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    access_key: str = Field(..., alias="access-key", description="The AWS access key")
    bucket: str = Field(..., description="The name of the S3 bucket")
    oidc_role: str | None = Field(
        default=None, alias="oidc-role", description="The OIDC role to assume"
    )
    region: str = Field(..., description="The AWS region")
    secret_key: str = Field(..., alias="secret-key", description="The AWS secret key")


class StorageAwsAuth2(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    access_key: str | None = Field(
        default=None, alias="access-key", description="The AWS access key"
    )
    bucket: str = Field(..., description="The name of the S3 bucket")
    oidc_role: str = Field(
        ..., alias="oidc-role", description="The OIDC role to assume"
    )
    region: str = Field(..., description="The AWS region")
    secret_key: str | None = Field(
        default=None, alias="secret-key", description="The AWS secret key"
    )


class StorageAwsAuth(RootModel[StorageAwsAuth1 | StorageAwsAuth2]):
    root: StorageAwsAuth1 | StorageAwsAuth2 = Field(
        ...,
        description="Amazon web services self hosted storage",
        title="Custom aws self hosted storage",
    )


class StorageGcpAuth(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    bucket: str = Field(..., description="The name of the GCP bucket")
    key_file: str = Field(
        ...,
        alias="key-file",
        description="The GCP key file contents encoded in Base64 format",
    )


class Variable(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    allowed_values: list[str] | None = Field(
        default=None,
        alias="allowed-values",
        description="A list of values that are allowed for the variable.",
        min_length=1,
        title="Allowed Variable Values",
    )
    default: str | None = Field(default=None, title="Default Variable Value")
    description: str | None = Field(default=None, title="Variable Description")
    name: str = Field(..., title="Variable Name")


class VariablesItem(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    variables: list[Variable] | None = Field(
        default=None,
        description="List of variables for the custom pipeline.",
        min_length=1,
        title="Custom Pipeline Variables",
    )


class Changesets(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    excludePaths: list[str] | None = Field(
        default=None,
        description="Condition which holds only if all of the modified files match any of the specified patterns.",
        min_length=1,
        title="Exclude Paths",
    )
    includePaths: list[str] | None = Field(
        default=None,
        description="Condition which holds only if any of the modified files match any of the specified patterns.",
        min_length=1,
        title="Include Paths",
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    changesets: Changesets = Field(
        ...,
        description="Condition on the changesets involved in the pipeline.",
        title="Changeset Condition",
    )


class Trigger(RootModel[Literal["automatic", "manual"]]):
    root: Literal["automatic", "manual"]


class FailFast(RootModel[bool]):
    root: bool = Field(..., title="Fail Fast")


class Download(RootModel[list[str]]):
    root: list[str] = Field(
        ...,
        description="Define the list of filtered artifacts to be downloaded by the step.",
        min_length=1,
    )


class ArtifactsPaths(RootModel[list[str]]):
    root: list[str] = Field(..., min_length=1)


class Pipe(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    pipe: str = Field(
        ..., description="The full pipe identifier.", title="Pipe Identifier"
    )
    variables: dict[str, str | list[str]] | None = Field(
        default=None,
        description="Environment variables passed to the pipe container.",
        title="Pipe Variables",
    )


class ArtifactsUpload(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    capture_on: Literal["success", "failed", "always"] | None = Field(
        default=None,
        alias="capture-on",
        description="The capture on field for the artifact.",
        title="Artifact Capture On",
    )
    depth: int | None = Field(
        default=None,
        description="The depth to search for the artifact files.",
        ge=1,
        title="Artifact Depth",
    )
    ignore_paths: list[str] | None = Field(
        default=None,
        alias="ignore-paths",
        description="The ignore paths for the artifact.",
        title="Artifact Ignore Paths",
    )
    name: str = Field(
        ..., description="The name of the artifact.", title="Artifact Name"
    )
    paths: ArtifactsPaths
    type: Literal["shared", "scoped", "test-reports"] | None = Field(
        default="shared", description="The type of the artifact.", title="Artifact Type"
    )


class TriggerConfigurationList(RootModel[list[TriggerConfiguration]]):
    root: list[TriggerConfiguration] = Field(
        ...,
        description="List of trigger configurations for a specific trigger type.",
        min_length=1,
        title="Trigger Configuration List",
    )


class CacheExpanded(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    key: Key | None = Field(default=None, title="Cache Key")
    path: CachePath


class ImageAwsAuth(ImageBase):
    model_config = ConfigDict(
        extra="allow",
    )
    aws: Aws | Aws1


class ImageBasicAuth(ImageBase):
    model_config = ConfigDict(
        extra="allow",
    )
    password: str = Field(
        ...,
        description="The password to use when fetching the Docker image.",
        title="Docker Registry Password",
    )
    username: str = Field(
        ...,
        description="The username to use when fetching the Docker image.",
        title="Docker Registry Username",
    )


class ImageNoAuth(ImageBase):
    model_config = ConfigDict(
        extra="allow",
    )
    aws: Any | None = None
    password: Any | None = None
    username: Any | None = None


class RunsOnExpanded(RootModel[list[RunsOnItem]]):
    root: list[RunsOnItem] = Field(
        ...,
        description="Required labels of a runner to run the step.",
        examples=[["self.hosted", "linux"]],
        max_length=10,
        min_length=1,
        title="Step Runner Labels",
    )


class Storage(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    gcp: StorageGcpAuth


class Storage1(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    aws: StorageAwsAuth


class SelfHosted(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    cpu: int | None = Field(
        default=None, description="Cpu available to runner.", title="Cpu"
    )
    memory: int | None = Field(
        default=None, description="Memory (mb) available to runner.", title="Memory"
    )
    storage: Storage | Storage1 | None = None
    volumes: list[str] | None = Field(
        default=[], description="Volumes to be mounted into the build container."
    )


class Script(RootModel[list[str | Pipe | ScriptItemAnchor]]):
    root: list[str | Pipe | ScriptItemAnchor] = Field(..., min_length=1)


class ArtifactsExpanded(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    download: bool | Download | None = None
    paths: ArtifactsPaths | None = None
    upload: list[ArtifactsUpload] | None = Field(default=None, min_length=1)


class Cache(RootModel[CachePath | CacheExpanded]):
    root: CachePath | CacheExpanded


class Image(RootModel[ImageNoAuth | ImageBasicAuth | ImageAwsAuth | ImageName]):
    root: ImageNoAuth | ImageBasicAuth | ImageAwsAuth | ImageName


class RunsOn(RootModel[RunsOnItem | RunsOnExpanded]):
    root: RunsOnItem | RunsOnExpanded


class Runtime(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    cloud: Cloud | None = None
    self_hosted: SelfHosted | None = Field(default=None, alias="self-hosted")


class Service(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    image: Image | None = None
    memory: int | None = Field(
        default=None,
        description="Memory limit for the service container, in megabytes.",
        ge=128,
        title="Service Memory",
    )
    type: Literal["docker"] | None = Field(
        default=None,
        description="Specifies Docker service container (to run Docker-in-Docker).",
    )
    variables: dict[str, str] | None = Field(
        default=None,
        description="Environment variables passed to the service container.",
        title="Service Variables",
    )


class Artifacts(RootModel[ArtifactsPaths | ArtifactsExpanded]):
    root: ArtifactsPaths | ArtifactsExpanded


class Options(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    docker: bool | None = Field(
        default=False, description="Enables Docker service for every step."
    )
    max_time: MaxTime | None = Field(default=None, alias="max-time")
    runs_on: RunsOn | None = Field(default=None, alias="runs-on")
    runtime: Runtime | None = None
    size: Size | None = None


class StepBase(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    after_script: Script | None = Field(
        default=None,
        alias="after-script",
        description="List of commands to execute after the step succeeds or fails.",
        title="Step Post Script",
    )
    artifacts: Artifacts | None = None
    caches: list[str] | None = Field(
        default=None,
        description="Caches enabled for the step.",
        min_length=1,
        title="Step Caches",
    )
    clone: Clone | None = None
    concurrency_group: str | None = Field(
        default=None,
        alias="concurrency-group",
        description="The concurrency group for the step.",
        max_length=50,
        title="Concurrency group",
    )
    custom: str | None = Field(
        default=None,
        description="The name of the custom pipeline to run, if the step type is pipeline.",
        title="Custom",
    )
    deployment: str | None = Field(
        default=None,
        description="The deployment environment for the step.",
        title="Step Deployment Environment",
    )
    environment: str | None = Field(
        default=None,
        description="The environment for the step.",
        title="Step Environment",
    )
    fail_fast: FailFast | None = Field(
        default=None,
        alias="fail-fast",
        description="Stop the parent parallel group in case this step fails.",
    )
    image: Image | None = None
    input_variables: dict[str, str] | None = Field(
        default=None,
        alias="input-variables",
        description="Variables from the parent step that are provided to the child pipeline.",
        examples=[{"VAR_1": "VALUE_1", "VAR_2": "${BITBUCKET_BRANCH}"}],
        title="Input Variables",
    )
    max_time: MaxTime | None = Field(
        default=None,
        alias="max-time",
        title="Step Maximum Time",
    )
    name: str | None = Field(
        default=None,
        description="The name of the step.",
        examples=["Build and test"],
        title="Step Name",
    )
    oidc: bool | None = Field(
        default=None,
        description="Enables the use of OpenID Connect to connect a pipeline step to a resource server.",
    )
    runs_on: RunsOn | None = Field(default=None, alias="runs-on")
    runtime: Runtime | None = None
    script: Script = Field(
        ...,
        description="List of commands that are executed in sequence.",
        title="Step Script",
    )
    services: list[str] | None = Field(
        default=None,
        description="Services enabled for the step.",
        max_length=5,
        min_length=1,
        title="Step Services",
    )
    size: Size | None = None
    trigger: Trigger | None = Field(
        default=None,
        description="The trigger used for the pipeline step.",
        title="Step Trigger",
    )
    type: Literal["inline", "pipeline", "shared"] | None = Field(
        default="shared", description="The type of the step.", title="Step Type"
    )


class Step2(StepBase):
    model_config = ConfigDict(
        extra="allow",
    )
    condition: Any | None = None


class Step1(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    step: Step2


class Stage(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    condition: Condition | None = Field(
        default=None,
        description="The condition to execute the stage.",
        title="Stage Condition",
    )
    deployment: str | None = Field(
        default=None,
        description="The deployment environment for the stage.",
        title="Stage Deployment Environment",
    )
    environment: str | None = Field(
        default=None,
        description="The environment for the stage.",
        title="Stage Environment",
    )
    name: str | None = Field(
        default=None, description="The name of the stage.", title="Stage Name"
    )
    steps: list[Step1] = Field(
        ...,
        description="List of steps in the stage.",
        min_length=1,
        title="Stage Steps",
    )
    trigger: Trigger | None = Field(
        default=None,
        description="The trigger used for the pipeline stage.",
        title="Stage Trigger",
    )


class Step(StepBase):
    model_config = ConfigDict(
        extra="allow",
    )
    condition: Condition | None = Field(
        default=None,
        description="The condition to execute the step.",
        title="Step Condition",
    )


class StageItem(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    stage: Stage


class StepItem(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    step: Step


class ParallelSteps(RootModel[list[StepItem]]):
    root: list[StepItem] = Field(
        ...,
        description="List of steps in the parallel group to run concurrently.",
        min_length=1,
        title="Parallel Group Steps",
    )


class ParallelExpanded(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    fail_fast: FailFast | None = Field(
        default=None,
        alias="fail-fast",
        description="Stop the whole parallel group in case one of its steps fails.",
    )
    steps: ParallelSteps


class Parallel(RootModel[ParallelSteps | ParallelExpanded]):
    root: ParallelSteps | ParallelExpanded


class ParallelItem(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    parallel: Parallel


class Items(RootModel[list[StepItem | ParallelItem | StageItem]]):
    root: list[StepItem | ParallelItem | StageItem] = Field(
        ...,
        description="List of steps, stages and parallel groups of the pipeline.",
        min_length=1,
        title="Pipeline Items",
    )


class ItemsWithVariables(
    RootModel[list[VariablesItem | StepItem | ParallelItem | StageItem]]
):
    root: list[VariablesItem | StepItem | ParallelItem | StageItem] = Field(
        ...,
        description="List of variables, steps, stages and parallel groups of the custom pipeline.",
        min_length=1,
        title="Custom Pipeline Items",
    )


class CustomPipeline(RootModel[ItemsWithVariables | ImportPipeline]):
    root: ItemsWithVariables | ImportPipeline


class Pipeline(RootModel[Items | ImportPipeline]):
    root: Items | ImportPipeline


class PullRequestsPipeline1(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    destinations: dict[str, Pipeline] | None = None


class PullRequestsPipeline(RootModel[Items | PullRequestsPipeline1]):
    root: Items | PullRequestsPipeline1


class Definitions(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    caches: dict[str, Cache] | None = Field(
        default=None, title="Custom cache definitions"
    )
    pipelines: dict[str, CustomPipeline] | None = Field(
        default=None,
        description="Definitions of the pipelines which can be used in other repositories of the same Bitbucket workspace.",
        title="Shared pipeline definitions",
    )
    services: dict[str, Service] | None = Field(
        default=None, title="Service definitions"
    )
    script_items: list[str | Pipe] | None = Field(
        default=None, title="Script Item definitions"
    )


class Pipelines(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    branches: dict[str, Pipeline] | None = Field(
        default=None,
        description="Branch-specific build pipelines.",
        title="Branch Pipelines",
    )
    custom: dict[str, CustomPipeline] | None = Field(
        default=None,
        description="Pipelines that can only be triggered manually or be scheduled.",
        title="Custom Pipelines",
    )
    default: Pipeline | None = Field(
        default=None,
        description="Default pipeline runs on every push except for tags unless a branch-specific pipeline is defined.",
        title="Default Pipeline",
    )
    pull_requests: dict[str, PullRequestsPipeline] | None = Field(
        default=None,
        alias="pull-requests",
        description="Pull-request-specific build pipelines.",
        title="Pull Request Pipelines",
    )
    tags: dict[str, Pipeline] | None = Field(
        default=None, description="Tag-specific build pipelines.", title="Tag Pipelines"
    )


class PipelinesConfiguration(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    clone: Clone | None = None
    definitions: Definitions | None = Field(
        default=None,
        description="The definitions of caches and services used in the declared pipelines.",
        title="Global Definitions",
    )
    export: bool | None = Field(
        default=None,
        description="Allows other Bitbucket repositories to import pipeline definitions from this file. A shared pipeline definition can't contain another `import` property.",
        title="Enables shared pipelines definitions.",
    )
    image: Image | None = None
    labels: dict[str, Any] | None = Field(
        default=None,
        description="Additional key value data supplied in the configuration YAML.",
        examples=[{"buildTool": "maven", "jvm": "jdk17"}],
        title="Pipeline Labels",
    )
    options: Options | None = Field(
        default=None,
        description="Global options allow to override the default values applied to all steps in all declared pipelines.",
        title="Global Options",
    )
    pipelines: Pipelines | None = Field(default=None, title="Pipelines")
    triggers: dict[str, TriggerConfigurationList] | None = Field(
        default=None,
        description="Event-based triggers that automatically run pipelines when specific events occur. The property names represent trigger types (e.g., repository-push, pullrequest-push).",
        examples=[
            {
                "pullrequest-push": [
                    {
                        "condition": 'BITBUCKET_PR_DESTINATION_BRANCH == "main"',
                        "pipelines": ["pipeline2"],
                    }
                ],
                "repository-push": [
                    {
                        "condition": 'BITBUCKET_BRANCH == "main"',
                        "pipelines": ["pipeline1"],
                    }
                ],
            }
        ],
        title="Pipeline Triggers",
    )


class Model(RootModel[PipelinesConfiguration]):
    root: PipelinesConfiguration
